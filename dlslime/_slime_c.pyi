from __future__ import annotations
import collections.abc
import torch
import typing
import typing_extensions
__all__: list[str] = ['AllToAllIntraLLBuffer', 'Assignment', 'OpCode', 'RDMAContext', 'RDMAEndpoint', 'RDMAWorker', 'available_nic', 'socket_id']
class AllToAllIntraLLBuffer:
    def __init__(self, arg0: typing.SupportsInt, arg1: typing.SupportsInt, arg2: typing.SupportsInt, arg3: typing.SupportsInt, arg4: typing.SupportsInt) -> None:
        ...
    def all_to_all_ll(self, x: torch.Tensor, is_transpose: bool = False, mask: torch.Tensor | None = None) -> torch.Tensor:
        """
        AllGather with optional mask
        """
    def buffer_info(self) -> dict:
        ...
    def connect_full_mesh(self, arg0: collections.abc.Sequence[json]) -> int:
        ...
    def get_buffer_size_hint(self: typing.SupportsInt, arg0: typing.SupportsInt, arg1: typing.SupportsInt, arg2: typing.SupportsInt) -> int:
        ...
    def get_local_buffer(self) -> torch.Tensor:
        ...
    def set_max_bs(self, arg0: typing.SupportsInt) -> int:
        ...
class Assignment:
    @typing.overload
    def __init__(self, arg0: typing.SupportsInt, arg1: typing.SupportsInt, arg2: typing.SupportsInt, arg3: typing.SupportsInt) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: typing.SupportsInt, arg1: typing.SupportsInt, arg2: typing.SupportsInt, arg3: typing.SupportsInt, arg4: typing.SupportsInt) -> None:
        ...
class OpCode:
    """
    Members:
    
      READ
    
      WRITE
    
      WRITE_WITH_IMM_DATA
    
      SEND
    
      RECV
    """
    READ: typing.ClassVar[OpCode]  # value = <OpCode.READ: 0>
    RECV: typing.ClassVar[OpCode]  # value = <OpCode.RECV: 3>
    SEND: typing.ClassVar[OpCode]  # value = <OpCode.SEND: 2>
    WRITE: typing.ClassVar[OpCode]  # value = <OpCode.WRITE: 1>
    WRITE_WITH_IMM_DATA: typing.ClassVar[OpCode]  # value = <OpCode.WRITE_WITH_IMM_DATA: 5>
    __members__: typing.ClassVar[dict[str, OpCode]]  # value = {'READ': <OpCode.READ: 0>, 'WRITE': <OpCode.WRITE: 1>, 'WRITE_WITH_IMM_DATA': <OpCode.WRITE_WITH_IMM_DATA: 5>, 'SEND': <OpCode.SEND: 2>, 'RECV': <OpCode.RECV: 3>}
    def __eq__(self, other: typing.Any) -> bool:
        ...
    def __getstate__(self) -> int:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    def __init__(self, value: typing.SupportsInt) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __setstate__(self, state: typing.SupportsInt) -> None:
        ...
    def __str__(self) -> str:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class RDMAContext:
    def __init__(self) -> None:
        ...
    def init(self, arg0: str, arg1: typing.SupportsInt, arg2: str) -> int:
        ...
    def launch_future(self) -> None:
        ...
    def reload_memory_pool(self) -> int:
        ...
    def stop_future(self) -> None:
        ...
class RDMAEndpoint:
    @typing.overload
    def __init__(self, num_qp: typing.SupportsInt = 1, context: RDMAContext = None, worker: ... = None) -> None:
        ...
    @typing.overload
    def __init__(self, num_qp: typing.SupportsInt = 1, device_name: str = '', ib_port: typing.SupportsInt = 1, link_type: str = 'RoCE', worker: ... = None) -> None:
        ...
    def connect(self, arg0: dict) -> None:
        ...
    def endpoint_info(self) -> dict:
        ...
    def process(self) -> int:
        ...
    def read(self, arg0: collections.abc.Sequence[typing.SupportsInt], arg1: collections.abc.Sequence[typing.SupportsInt], arg2: collections.abc.Sequence[typing.SupportsInt], arg3: collections.abc.Sequence[typing.SupportsInt], arg4: collections.abc.Sequence[typing.SupportsInt], arg5: typing.Any) -> int:
        ...
    def recv(self, data_ptr: typing.SupportsInt, offset: typing.SupportsInt, length: typing.SupportsInt, stream_handler: typing.Any = None) -> int:
        ...
    def recv_imm(self, stream: typing.Any = None) -> int:
        ...
    def register_memory_region(self, arg0: typing.SupportsInt, arg1: typing.SupportsInt, arg2: typing.SupportsInt) -> int:
        ...
    def register_remote_memory_region(self, arg0: typing.SupportsInt, arg1: dict) -> int:
        ...
    def send(self, data_ptr: typing.SupportsInt, offset: typing.SupportsInt, length: typing.SupportsInt, stream_handler: typing.Any = None) -> int:
        ...
    def wait(self, slot_id: typing.SupportsInt) -> int:
        ...
    def wait_recv(self, slot_id: typing.SupportsInt) -> int:
        ...
    def wait_recv_imm(self, slot_id: typing.SupportsInt) -> int:
        ...
    def wait_send(self, slot_id: typing.SupportsInt) -> int:
        ...
    def write(self, arg0: collections.abc.Sequence[typing.SupportsInt], arg1: collections.abc.Sequence[typing.SupportsInt], arg2: collections.abc.Sequence[typing.SupportsInt], arg3: collections.abc.Sequence[typing.SupportsInt], arg4: collections.abc.Sequence[typing.SupportsInt], arg5: typing.Any) -> int:
        ...
    def write_with_imm(self, arg0: collections.abc.Sequence[typing.SupportsInt], arg1: collections.abc.Sequence[typing.SupportsInt], arg2: collections.abc.Sequence[typing.SupportsInt], arg3: collections.abc.Sequence[typing.SupportsInt], arg4: collections.abc.Sequence[typing.SupportsInt], arg5: typing.SupportsInt, arg6: typing.Any) -> int:
        ...
class RDMAWorker:
    @typing.overload
    def __init__(self, dev_name: str, id: typing.SupportsInt) -> None:
        ...
    @typing.overload
    def __init__(self, socket_id: typing.SupportsInt, id: typing.SupportsInt) -> None:
        ...
    def add_endpoint(self, endpoint: RDMAEndpoint) -> None:
        ...
    def start(self) -> None:
        ...
    def stop(self) -> None:
        ...
def available_nic() -> list[str]:
    ...
def socket_id(arg0: str) -> int:
    ...
_BUILD_INTER_OPS: bool = False
_BUILD_INTRA_OPS: bool = True
_BUILD_NVLINK: bool = False
_BUILD_NVSHMEM: bool = False
_BUILD_RDMA: bool = True
